<!DOCTYPE html>
<html>

<head>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="https://d3js.org/d3-selection-multi.v1.min.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  <style>
    .info-box {
      box-shadow: 5px 10px #888888;
    }

    .baseline {
      stroke-dasharray: 4 4;
    }
  </style>
</head>

<body>

</body>
<script>
  var canvasSize = 960;
  var drawingPaths = [];
  var randPointGenY = d3.scaleLinear()
    .domain([0.0, 0.5, 1.0])
    .range([-15, 8, 15]);
  var randPointGenX = d3.scaleLinear()
    .domain([0.0, 0.5, 1.0])
    .range([-30, 15, 30]);
  var svg = d3.select("body").append("svg")
    .attr("width", canvasSize)
    .attr("height", canvasSize)
    .call(d3.zoom().on("zoom", function () {
      svg.attr("transform", d3.event.transform)
    }));
  //.call(draw);
  prePathData = [
    [12, 152],
    [701, 152]
  ];
  prePathData1 = [
    [12, 172],
    [701, 172]
  ];
  prePathData2 = [
    [133, 12],
    [129, 309]
  ];
  /*[
      [351, 11],
      [347, 305]
    ],
    [
      [561, 14],
      [560, 309]
    ] */

  // .call(d3.zoom().on("zoom", function () {
  //   svg.attr("transform", d3.event.transform)
  // }))
  var nodeCanvas = svg.append('g').attr('class', 'node-canvas');
  var pathDrawCanvas = svg.append('g').attr('class', 'path-draw-canvas');
  var pathCanvas = svg.append('g').attr('class', 'path-canvas');
  var longPathCanvas = svg.append('g').attr('class', 'long-canvas');
  var legendCanvas = svg.append('g').attr('class', 'legend-canvas');
  var infoCanvas = svg.append('g').attr('class', 'info-canvas');

  pathLine = d3.line()
    .x(function (d) {
      return d[0];
    })
    .y(function (d) {
      return d[1];
    });
  path1 = pathLine(prePathData);
  path3 = pathLine(prePathData2);
  doublePath = path1 + path3;
  possiblePath = pathDrawCanvas.append('path').datum(prePathData)
    .attr('d', doublePath)
    .attrs({
      'stroke': 'grey',
      'stroke-width': '0.5',
      opacity: 0.3
    }).classed("baseline", !0);
  d3.json('node.json').then(function (rects) {
    nodeCanvas.selectAll('rect').data(rects).enter().append('rect').each(function (d, i) {
      d3.select(this).attrs({
        id: d.id,
        x: d.x,
        y: d.y,
        width: d.width,
        height: d.height,
        'stroke-width': 1,
        'stroke': 'black',
        fill: 'none'
      });
    });
    renderPah();
  })

  pathDensityGroup = {};
  pathLengthGroup = [];
  pathDensityColor = d3.piecewise(d3.interpolateHsl, ["green", "orange", "red", "black"])
  multiColor = d3.interpolateRainbow;
  schemeOranges = d3.interpolateOranges;
  schemeBlue = d3.interpolateBlues;

  var curveLine = d3.line().x(function (d) {
    return d[0]
  }).y(function (d) {
    return d[1]
  }).curve(d3.curveLinear);
  //}).curve(d3.curveCardinal.tension(0));

  function renderPah() {
    d3.csv("data.csv").then(function (productMoves) {
      let productGroup = d3.nest()
        .key(function (d) {
          return d.product;
        })
        .entries(productMoves);
      for (idx in productGroup) {
        let productIdx = parseInt(idx);
        let product = productGroup[idx];
        var points = [];
        for (node of product.values) {
          try {
            let bBox = d3.select('#' + node.node).node().getBBox();


            let point = {
              x: (bBox.x + bBox.width / 2),
              y: (bBox.y + bBox.height / 2)
            }
            //console.log("Actual ", idx, point);
            var lineDirection = closestPoint(possiblePath.node(), [point.x, point.y])
            if (point.x == lineDirection[0]) {
              point.x = point.x + (productIdx * 3);
            } else {
              point.y = point.y + (productIdx * 3);
            }
            //console.log("Shift ", idx, point);
            points.push(point)

          } catch (e) {
            console.log(e);
          }

        }
        let productPath = '';
        singlePathPoints = [];
        jaggedPoints = [];
        pairwise(points, function (current, next, index) {
          //singlePathPoints.push(...[current, next]);
          let x1 = closestPoint(possiblePath.node(), [current.x, current.y])
          if (current.x == x1[0]) {
            current.x = current.x + 2;
            x1[0] = x1[0] + 2
            x1[1] = x1[1] + productIdx * 2
          } else {
            current.y = current.y + 2;
            x1[1] = x1[1] + 2
            x1[0] = x1[0] + productIdx * 2
          }
          let x2 = closestPoint(possiblePath.node(), [next.x, next.y])
          if (next.x == x2[0]) {
            next.x = next.x + 2;
            x2[0] = x2[0] + 2;
            x2[1] = x2[1] + productIdx * 2;
          } else {
            next.y = next.y + 2;
            x2[1] = x2[1] + 2;
            x2[0] = x2[0] + productIdx * 2
          }
          midPointOfX1X2 = [];
          midPointOfX1X2[0] = Math.round(Math.abs(x2[0] + x1[0]) / 2, 1);
          midPointOfX1X2[1] = Math.round(Math.abs(x2[1] + x1[1]) / 2, 1);

          // svg.append('circle').attrs({
          //   cx: midPointOfX1X2[0],
          //   cy: midPointOfX1X2[1],
          //   r: 1,
          //   fill: 'black',
          //   opacity: 0.5
          // });
          linePoint = closestPoint(possiblePath.node(), midPointOfX1X2);
          //console.log(midPointOfX1X2, linePoint);
          // let midPoints = [{
          //   x: x1[0],
          //   y: x1[1]
          // }, {
          //   x: x2[0],
          //   y: x2[1]
          // }]
          //if(singlePathPoints[singlePathPoints.length-1])
          newPoint = [];
          singlePathPoints.push([current.x, current.y]);
          singlePathPoints.push([x1[0], x1[1]]);

          if (linePoint.distance > 0) {
            if (linePoint[0] == midPointOfX1X2[0]) {
              newPoint[0] = x1[0]
              newPoint[1] = linePoint[1];

            } else {
              newPoint[1] = x1[1]
              newPoint[0] = linePoint[0];
            }
            if (x1[0] == newPoint[0]) {
              newPoint[1] = newPoint[1] + productIdx * 2
            } else {
              newPoint[0] = newPoint[0] + productIdx * 2
            }
          }
          // svg.append('circle').attrs({
          //   cx: newPoint[0],
          //   cy: newPoint[1],
          //   r: 1,
          //   fill: 'black'
          // })
          // svg.append('circle').attrs({
          //   cx: linePoint[0],
          //   cy: linePoint[1],
          //   r: 1,
          //   fill: 'black'
          // })
          singlePathPoints.push(newPoint);
          singlePathPoints.push([x2[0], x2[1]]);
          singlePathPoints.push([next.x, next.y]);


          jaggedPoints.push(...createJaggedPoints([current.x, current.y], [x1[0], x1[1]], 0, 0))
          //productPath += curveLine(finalPoints);
          if (newPoint.length > 0) {
            jaggedPoints.push(...createJaggedPoints([x1[0], x1[1]], [newPoint[0], newPoint[1]], 0, 0))
            jaggedPoints.push(...createJaggedPoints([newPoint[0], newPoint[1]], [x2[0], x2[1]], 0, 0))
          } else {
            jaggedPoints.push(...createJaggedPoints([x1[0], x1[1]], [x2[0], x2[1]], 0, 0))
          }

          //productPath += curveLine(finalPoints);
          jaggedPoints.push(...createJaggedPoints([x2[0], x2[1]], [next.x, next.y], 0, 0))
          //productPath += curveLine(finalPoints);
        });
        //finalPoints = []
        //console.log(singlePathPoints);
        productPath = curveLine(jaggedPoints);
        let factor = ((productIdx + 2) / (productGroup.length + 2));
        //console.log(points);

        //console.log(productPath);
        let path = pathCanvas.append('path').attrs({
            d: productPath,
            stroke: multiColor(factor),
            'stroke-width': 1,
            "fill": "none",
            opacity: 0.7,
            class: 'move-path',
          }).call(function (t) {
            return transitionLine(t, 400)
          })
          .on('mouseover', function () {
            renderInfoCanvas({
              product: product.values[0].product,
              production_no: product.values[0].production_no
            }, {
              x: d3.mouse(this)[0],
              y: d3.mouse(this)[1]
            })
            d3.select(this).attrs({
              'opacity': 1,
              'stroke-width': 1.5
            })
          }).on('mouseout', function () {
            removeInfoCanvas();
            d3.select(this).attrs({
              'opacity': 0.7,
              'stroke-width': 1
            })
          });
        //path.data(product.values[0]);
      }
    })
  }

  function renderInfoCanvas(data, position) {
    infoCanvas.append('rect').attrs({
      class: 'info-box',
      x: position.x + 10,
      y: position.y + 10,
      width: 140,
      height: 60,
      fill: 'white',
      'stroke-width': 1,
      'stroke': 'black',
    })
    infoCanvas.append("text").text("Product name: " + data.product).attrs({
      x: position.x + 15,
      y: position.y + 30
    })
    infoCanvas.append("text").text("Product Line: " + data.production_no).attrs({
      x: position.x + 15,
      y: position.y + 50
    })
  }

  function removeInfoCanvas() {
    infoCanvas.selectAll('text').remove();
    infoCanvas.selectAll('rect').remove();
  }

  function pairwise(arr, func, skips) {

    skips = skips || 1;
    for (var i = 0; i < arr.length - skips; i++) {
      func(arr[i], arr[i + skips], i)
    }
  }
  var lineFunction = d3.line().x(function (d) {
    return d.x;
  }).y(function (d) {
    return d.y;
  });

  function scrollZoom(selection) {
    d3.zoom().on("zoom", function () {
      selection.attr("transform", d3.event.transform)
    })
  }

  function draw(selection) {
    var xy0,
      path,
      keep = false,
      line = d3.line()
      .x(function (d) {
        return d[0];
      })
      .y(function (d) {
        return d[1];
      });
    path = null;
    selection.on('mousedown', function () {
        keep = true;
        xy0 = d3.mouse(this);
        path = d3.select('svg')
          .append('path')
          .attr('d', line([xy0, xy0]))
          .attrs({
            'stroke': 'yellow',
            'stroke-width': '1'
          });
      })
      .on('mouseup', function () {
        keep = false;
        endXY = d3.mouse(this);
        drawingPaths.push([xy0, [endXY[0] - 1, endXY[1] - 1]])
        console.log(JSON.stringify(drawingPaths));
      })
      .on('mousemove', function () {
        if (keep) {

          Line = line([xy0, d3.mouse(this).map(function (x) {
            return x - 1;
          })]);
          path.attr('d', Line);
        }
      });


  }

  function closestPoint(pathNode, point) {
    var pathLength = pathNode.getTotalLength(),
      precision = 8,
      best,
      bestLength,
      bestDistance = Infinity;

    // linear scan for coarse approximation
    for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {
      if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
        best = scan, bestLength = scanLength, bestDistance = scanDistance;
      }
    }

    // binary search for precise estimate
    precision /= 2;
    while (precision > 0.5) {
      var before,
        after,
        beforeLength,
        afterLength,
        beforeDistance,
        afterDistance;
      if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode
          .getPointAtLength(beforeLength))) < bestDistance) {
        best = before, bestLength = beforeLength, bestDistance = beforeDistance;
      } else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after =
          pathNode.getPointAtLength(afterLength))) < bestDistance) {
        best = after, bestLength = afterLength, bestDistance = afterDistance;
      } else {
        precision /= 2;
      }
    }

    best = [best.x, best.y];
    best.distance = Math.sqrt(bestDistance);
    return best;

    function distance2(p) {
      var dx = p.x - point[0],
        dy = p.y - point[1];
      return dx * dx + dy * dy;
    }
  }

  function rotate(t, a, n) {
    var e = t[0],
      i = t[1],
      r = a[0],
      d = a[1],
      h = e + (r - e) * Math.cos(n) - (d - i) * Math.sin(n),
      o = i + (r - e) * Math.sin(n) + (d - i) * Math.cos(n);
    return [h, o]
  }

  function createJaggedPoints(t, a, n, e) {
    var i = !1;
    if (t[0] > a[0]) {
      var r = t;
      t = a, a = r, i = !0
    }
    var d = t[0],
      h = t[1],
      o = a[0],
      s = a[1],
      g = [t],
      u = s - h,
      c = o - d,
      p = -Math.atan(u / c),
      l = Math.sqrt(Math.pow(o - d, 2) + Math.pow(s - h, 2));
    e || (e = .05 * l);
    for (var v = rotate(t, a, p), w = v[0], m = v[1], f = d; f < w - e;) {
      var P = Math.min(f + e + Math.random() * e, w - e),
        M = n * (Math.random() - .5) + h;
      g.push([P, M]), f = P
    }
    g.push([w, m]);
    var k = g.map(function (n, e) {
      return 0 === e ? t : e === g.length - 1 ? a : rotate(t, n, -p)
    });
    return i ? k.reverse() : k
  }

  function transitionLine(t, a) {
    var n = t.node().getTotalLength();
    t.attr("stroke-dasharray", "0,100000").transition().duration(n / (a / 1e3)).ease(d3.easeQuadOut).attrTween(
      "stroke-dasharray",
      function () {
        var t = this.getTotalLength();
        return d3.interpolateString("0," + t, t + "," + t)
      }).on("end", function () {
      d3.select(this).attr("stroke-dasharray", "none")
    })
  }
</script>

</html>